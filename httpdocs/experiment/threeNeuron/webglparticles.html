<!DOCTYPE HTML>
<html lang="en">
	<head>
		<title>three.js webgl - particles</title>
		<meta charset="utf-8">
		<style type="text/css">
			body {
				background-color: #000000;
				margin: 0px;
				overflow: hidden;
				font-family:Monospace;
				font-size:13px;
				text-align:center;
				font-weight: bold;
				text-align:center;
			}

			a {
				color:#0078ff;
			}

			#info {
				color: #fff;
				position: absolute;
				top: 0px; width: 100%;
				padding: 5px;
				z-index: 100;
			}

		</style>
	</head>
	<body>

        <div id="info">
			<a href="http://github.com/mrdoob/three.js" target="_blank">three.js</a> - webgl particles example
		</div>
    
   
		<script type="text/javascript" src="../../libs/catmaid/request.js"></script>
    <script type="text/javascript" src="../../libs/jquery/jquery.js"></script>
   

		<script type="text/javascript" src="../../libs/three/build/Three.js"></script>

		<script type="text/javascript" src="../../libs/three/js/Detector.js"></script>
		<script type="text/javascript" src="../../libs/three/js/RequestAnimationFrame.js"></script>
		<script type="text/javascript" src="../../libs/three/js/Stats.js"></script>

		<script type="text/javascript">

			if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

			var container, stats;
			var camera, scene, renderer, particles, geometry, materials = [], parameters, i, h, color;
			var mouseX = 0, mouseY = 0;

			var windowHalfX = window.innerWidth / 2;
			var windowHalfY = window.innerHeight / 2;

      var neurontree;

			requestQueue = new RequestQueue();

      // watch as the connectome grows
      // setInterval ( "update_scene()", 5000 );
      
      init();
      update_tree( 3, 2330 )
      animate();   

      function update_tree( pid, tnid ) {
        requestQueue.register("../../model/export.skeleton.json.php", "GET", {
          pid: pid,
          tnid: tnid,
        }, function (status, text, xml)
        {
          if (status == 200)
          {
            console.log("update_tree");
            neurontree = $.parseJSON(text);
            update_scene();
          }
        });        
      }
      
      function update_scene() {
        console.log("update_scene");
        
        //init();
        //scene.removeChild( particles );
				geometry = new THREE.Geometry();

				for ( i = 0; i < neurontree.length; i++ ) {
          // create position for the node particle
          //console.log(Math.random() * 2000 - 1000);

          var x = parseFloat(neurontree[i].x);
          var y = parseFloat(neurontree[i].y);
          var z = parseFloat(neurontree[i].z);
          console.log(x,y,z);
					vector = new THREE.Vector3( x, y, z );
          //vector.normalize();
          //vector.multiplyScalar(100);
          console.log(vector);
					geometry.vertices.push( new THREE.Vertex( vector ) );

				}

				parameters = [ [ [1.0, 1.0, 1.0], 50]];
				//parameters = [ [ 0xff0000, 5 ], [ 0xff3300, 4 ], [ 0xff6600, 3 ], [ 0xff9900, 2 ], [ 0xffaa00, 1 ] ];
				//parameters = [ [ 0xffffff, 5 ], [ 0xdddddd, 4 ], [ 0xaaaaaa, 3 ], [ 0x999999, 2 ], [ 0x777777, 1 ] ];

        // for each skeleton, so far only one

        color = parameters[0][0];
        size  = parameters[0][1];
        
        //materials[i] = new THREE.ParticleBasicMaterial( { color: color, size: size } );

        materials[i] = new THREE.ParticleBasicMaterial( { size: size } );
        materials[i].color.setHSV( color[0], color[1], color[2] );

        
        particles = new THREE.ParticleSystem( geometry, materials[i] );
        /*
        particles.rotation.x = Math.random() * 6;
        particles.rotation.y = Math.random() * 6;
        particles.rotation.z = Math.random() * 6;
        */
        scene.addObject( particles );

				camera.position.y = 1000;
				camera.target.position.y = camera.position.y;
        
        
      }


			function init() {

				container = document.createElement( 'div' );
				document.body.appendChild( container );

/*
				camera = new THREE.Camera( 75, window.innerWidth / window.innerHeight, 1, 3000 );
				camera.position.z = 0;
  */      
				camera = new THREE.QuakeCamera( { fov: 60, aspect: window.innerWidth / window.innerHeight, near: 1, far: 20000,
												  movementSpeed: 50, lookSpeed: 0.0004, noFly: false, lookVertical: true } );

        camera.target.position.x = 3000;
        camera.target.position.y = 3000;
				camera.target.position.z = 0;
        
        camera.position.x = 0;
        camera.position.y = 0;
				camera.position.z = 0;

				scene = new THREE.Scene();
				// scene.fog = new THREE.FogExp2( 0x000000, 0.0007 );

				renderer = new THREE.WebGLRenderer();
				renderer.setSize( window.innerWidth, window.innerHeight );
				container.appendChild( renderer.domElement );

				stats = new Stats();
				stats.domElement.style.position = 'absolute';
				stats.domElement.style.top = '0px';
				container.appendChild( stats.domElement );

				document.addEventListener( 'mousemove', onDocumentMouseMove, false );
				document.addEventListener( 'touchstart', onDocumentTouchStart, false );
				document.addEventListener( 'touchmove', onDocumentTouchMove, false );

			}

			function onDocumentMouseMove( event ) {

				mouseX = event.clientX - windowHalfX;
				mouseY = event.clientY - windowHalfY;

			}

			function onDocumentTouchStart( event ) {

				if ( event.touches.length == 1 ) {

					event.preventDefault();

					mouseX = event.touches[ 0 ].pageX - windowHalfX;
					mouseY = event.touches[ 0 ].pageY - windowHalfY;

				}
			}

			function onDocumentTouchMove( event ) {

				if ( event.touches.length == 1 ) {

					event.preventDefault();

					mouseX = event.touches[ 0 ].pageX - windowHalfX;
					mouseY = event.touches[ 0 ].pageY - windowHalfY;

				}

			}

			//

			function animate() {

				requestAnimationFrame( animate );

				render();
				stats.update();

			}

			function render() {



/*
				var time = new Date().getTime() * 0.00005;

				camera.position.x += ( mouseX - camera.position.x ) * 0.05;
				camera.position.y += ( - mouseY - camera.position.y ) * 0.05;
        
				for( i = 0; i < scene.objects.length; i++ ) {

					scene.objects[i].rotation.y = time * ( i < 4 ? i+1 : - (i+1) );

				}

				for( i = 0; i < materials.length; i++ ) {

					color = parameters[i][0];

					h = ( 360 * ( color[0] + time ) % 360 ) / 360;
					materials[i].color.setHSV( h, color[1], color[2] );

				}

*/

				camera.position.x += ( mouseX - camera.position.x ) * .05;
				camera.position.y += ( - mouseY + 200 - camera.position.y ) * .05;
				camera.updateMatrix();

				var time = new Date().getTime() * 0.0015;

				for( var i = 0; i < scene.objects.length; i++ ) {

					scene.objects[ i ].rotation.y = time * ( i % 2 ? 1 : -1);

				}

				renderer.render( scene, camera );

			}


		</script>
	</body>
</html>
